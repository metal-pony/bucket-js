import * as subject from './perms.js';

const fail = (message = 'test nyi') => {
  throw new Error(message)
};

describe('factorial', () => {
  const badInputs = [-100, -10, -3, -2, -1];
  const facts = [
    1n, 1n, 2n, 6n, 24n, 120n, 720n, 5040n, 40320n, 362880n,
    3628800n,
    39916800n,
    479001600n,
    6227020800n,
    87178291200n,
    1307674368000n,
    20922789888000n,
    355687428096000n,
    6402373705728000n,
    121645100408832000n,
    2432902008176640000n,
    51090942171709440000n,
    1124000727777607680000n,
    25852016738884976640000n,
    620448401733239439360000n,
    15511210043330985984000000n,
    403291461126605635584000000n,
    10888869450418352160768000000n,
    304888344611713860501504000000n,
    8841761993739701954543616000000n,
    265252859812191058636308480000000n,
    8222838654177922817725562880000000n,
    263130836933693530167218012160000000n
  ];
  // For stress test
  const largeN = 1<<16;

  describe('for negative inputs', () => {
    test('throws', () => {
      badInputs.forEach(n => {
        expect(() => subject.factorial(n), `factorial(${n}) expected to throw`).toThrow();
      });
    });
  });

  test('returns the first few expected values', () => {
    facts.forEach((expected, n) => {
      expect(subject.factorial(n), `factorial(${n}) expected ${expected}`).toBe(expected);
    });
  });

  test('can handle large n', () => { subject.factorial(largeN); });
});

describe('permutation', () => {
  const permsExpected = [
    // BAD INPUTS
    // n < 0
    { n: -10, r: 0n, expected: 'err' },
    { n: -2, r: 0n, expected: 'err' },
    { n: -1, r: 0n, expected: 'err' },
    // r < 0
    { n: 0, r: -10n, expected: 'err' },
    { n: 0, r: -2n, expected: 'err' },
    { n: 0, r: -1n, expected: 'err' },
    // r >= n!
    { n: 0, r: 2n, expected: 'err' },
    { n: 1, r: 2n, expected: 'err' },
    { n: 10, r: 3628800n + 1n, expected: 'err' },

    // GOOD INPUTS
    // { n: 0, r: 0n, expected: [] },
    // { n: 1, r: 0n, expected: [0] },
    // { n: 2, r: 0n, expected: [0, 1] },
    // { n: 2, r: 1n, expected: [1, 0] },
    // { n: 3, r: 0n, expected: [0, 1, 2] },
    // { n: 3, r: 1n, expected: [0, 2, 1] },
    // { n: 3, r: 2n, expected: [1, 0, 2] },
    // { n: 3, r: 3n, expected: [1, 2, 0] },
    // { n: 3, r: 4n, expected: [2, 0, 1] },
    // { n: 3, r: 5n, expected: [2, 1, 0] },
    // { n: 4, r: 0n, expected: [0, 1, 2, 3] },
    // { n: 4, r: 1n, expected: [0, 1, 3, 2] },
    // { n: 4, r: 2n, expected: [0, 2, 1, 3] },
    // { n: 4, r: 3n, expected: [0, 2, 3, 1] },
    // { n: 4, r: 4n, expected: [0, 3, 1, 2] },
    // { n: 4, r: 5n, expected: [0, 3, 2, 1] },
    // { n: 4, r: 6n, expected: [1, 0, 2, 3] },
    // { n: 4, r: 7n, expected: [1, 0, 3, 2] },
    // { n: 4, r: 8n, expected: [1, 2, 0, 3] },
    // { n: 4, r: 9n, expected: [1, 2, 3, 0] },
    // { n: 4, r: 10n, expected: [1, 3, 0, 2] },
    // { n: 4, r: 11n, expected: [1, 3, 2, 0] },
    // { n: 4, r: 12n, expected: [2, 0, 1, 3] },
    // { n: 4, r: 13n, expected: [2, 0, 3, 1] },
    // { n: 4, r: 14n, expected: [2, 1, 0, 3] },
    // { n: 4, r: 15n, expected: [2, 1, 3, 0] },
    // { n: 4, r: 16n, expected: [2, 3, 0, 1] },
    // { n: 4, r: 17n, expected: [2, 3, 1, 0] },
    // { n: 4, r: 18n, expected: [3, 0, 1, 2] },
    // { n: 4, r: 19n, expected: [3, 0, 2, 1] },
    // { n: 4, r: 20n, expected: [3, 1, 0, 2] },
    // { n: 4, r: 21n, expected: [3, 1, 2, 0] },
    { n: 4, r: 22n, expected: [3, 2, 0, 1] },
    { n: 4, r: 23n, expected: [3, 2, 1, 0] },

    // Piece of cake.
    {
      n: 1010,
      r: 356379621448917474434312957290551465813162978310463560942136950186724696559930514459542616588548360340062615812243488425842829831933907076416213891046891062841494041466379077758817152750513059742663734323176668737724569422806140629968271362978058114859672996956451826009448416481176875449083503355502943110097843189658688418401897806367774697701960356312049337187195994395441902372739714180169969364996988308222951403815343076519550638806219814656310638396682452007739123222883631150109387444692074397021650917998546166460211762498516655551189174554022664354923436333631654459463087788725826301899994466951898781587703824280948224600991390485747670808489392466738005517472006366283482522344996144264162255183540638004022713613438777800467849258094553925252429753762468723240540344860154485562284981951120126168529138291934830737021191716062889214466230819901604155575258453618146237461843509372356772706100009433668362028624006004911310336449046325394099411837193462122297955403662826789406013829258039538752574646897934895134610089985522712263749459079083191466660099921386937475431469582629949753523149519772751451524306208748850794809727568917455786389862081236939315182245696973397838689895324387265532766426368855611517606040265841606759620141378356534895134937617069336861766884423840085666918536010443419791900535793507636950334055478446588030255283592896484486673114610037312155794426351316580570548780549761261615813611601493064654988400915996214418897927232564637550937467898401118461578150409427551988693355244542228056641830873893743126544702523116123386405612925241209004335970156696499909865132708591059302164104845347134584085088357438968570814729151413035703098036495962438862417379507601662474688156060333167442225258616264191769265188404838420566114215003281330680669344889898675680860953827618009136213986027222682494162015247393484452426077771266193846944730636656620654173151028591030072693660779580540144462959436928457357349885482778491431545566912408713938753990596806482959715298925346705143117416380332386969248934295505223952346928503986459526606239216120371794541960892394262678425822400518468718945949187854121355658259247903604585056552574715796872390446773578397936711093016915803698938140100137789544575590332628193172671868740925490536494972079351207426578455458678190703185742118135897482282712051090945238476812393655905559992891282726414053122262128216398082491542212605683343955993744324144607680833168455440568099135383767639332999858764679631304195943633132176000791481436939827510988573568161099974347759172057927060961447142688262293499245002172828676455401n,
      expected: [
        846, 819, 271, 91, 749, 526, 109, 409, 351, 117, 439, 826, 779, 691, 1002, 71,
        935, 742, 880, 708, 623, 484, 581, 308, 803, 429, 693, 41, 943, 202, 777, 954, 259, 638,
        641, 165, 366, 38, 889, 824, 490, 448, 746, 662, 791, 726, 927, 362, 257, 895, 234, 244,
        251, 841, 666, 959, 320, 78, 696, 571, 842, 408, 385, 588, 900, 266, 418, 389, 205, 302,
        300, 342, 222, 761, 348, 645, 427, 876, 359, 932, 140, 106, 715, 377, 260, 75, 131, 149,
        383, 863, 655, 242, 81, 309, 807, 747, 297, 333, 218, 397, 436, 510, 59, 381, 671, 952,
        237, 265, 316, 494, 808, 559, 15, 865, 268, 332, 148, 879, 270, 776, 420, 45, 811, 633,
        555, 1004, 505, 839, 529, 438, 93, 220, 364, 875, 162, 649, 160, 18, 974, 501, 925, 1009,
        155, 322, 608, 853, 169, 310, 861, 345, 908, 378, 778, 685, 375, 34, 579, 323, 334, 618,
        51, 79, 859, 937, 757, 567, 794, 962, 978, 82, 197, 907, 979, 607, 718, 240, 969, 582,
        132, 125, 930, 502, 353, 851, 997, 890, 480, 646, 28, 185, 350, 533, 977, 560, 284, 822,
        29, 679, 382, 147, 485, 313, 365, 860, 245, 522, 558, 443, 751, 325, 883, 21, 765, 788,
        901, 20, 209, 35, 254, 258, 898, 181, 710, 764, 553, 471, 133, 124, 449, 144, 318, 347,
        280, 689, 384, 470, 198, 373, 354, 40, 546, 892, 513, 584, 25, 758, 858, 386, 293, 814,
        395, 89, 105, 428, 915, 784, 756, 474, 252, 650, 837, 231, 54, 821, 772, 721, 743, 687,
        243, 405, 211, 340, 827, 128, 660, 672, 767, 403, 8, 984, 451, 305, 678, 543, 287, 625,
        413, 677, 307, 866, 442, 96, 157, 896, 482, 576, 768, 905, 296, 275, 855, 171, 476, 324,
        292, 684, 432, 870, 719, 288, 0, 910, 849, 611, 172, 387, 731, 227, 445, 840, 372, 503,
        55, 299, 431, 161, 85, 461, 6, 400, 991, 938, 123, 477, 683, 523, 126, 797, 77, 331, 379,
        118, 985, 57, 648, 512, 22, 100, 72, 817, 600, 957, 506, 369, 317, 110, 163, 315, 407,
        654, 84, 619, 575, 833, 720, 780, 626, 207, 844, 593, 519, 815, 634, 825, 16, 1006, 854,
        304, 248, 961, 964, 911, 444, 914, 3, 630, 712, 277, 464, 201, 177, 127, 282, 695, 812,
        208, 321, 90, 294, 700, 702, 850, 975, 24, 264, 319, 829, 363, 111, 956, 980, 556, 565,
        694, 775, 971, 986, 303, 899, 569, 225, 229, 130, 521, 47, 267, 456, 692, 857, 509, 398,
        190, 946, 632, 489, 769, 525, 421, 360, 1000, 174, 586, 955, 64, 568, 616, 741, 934, 818,
        539, 143, 311, 874, 50, 699, 441, 516, 504, 813, 358, 113, 852, 610, 376, 285, 659, 422,
        104, 286, 1005, 419, 970, 518, 585, 744, 368, 349, 701, 273, 88, 976, 1008, 374, 151, 542,
        940, 203, 921, 989, 32, 590, 551, 737, 868, 224, 219, 283, 301, 675, 76, 877, 73, 891,
        647, 447, 752, 636, 423, 188, 314, 7, 524, 396, 103, 594, 965, 168, 274, 922, 828, 601,
        142, 939, 154, 214, 199, 953, 996, 326, 944, 141, 466, 434, 473, 736, 9, 515, 538, 99,
        483, 673, 704, 878, 191, 835, 960, 37, 918, 972, 941, 888, 716, 42, 906, 717, 98, 424,
        192, 591, 481, 179, 628, 759, 371, 681, 339, 665, 291, 39, 622, 206, 640, 917, 615, 651,
        913, 150, 724, 246, 552, 11, 343, 491, 460, 189, 698, 121, 159, 580, 587, 920, 936, 609,
        928, 562, 327, 897, 115, 402, 847, 488, 344, 415, 94, 486, 945, 496, 643, 5, 356, 885,
        508, 983, 809, 498, 217, 745, 241, 919, 329, 738, 774, 909, 680, 722, 682, 800, 63, 223,
        178, 112, 164, 669, 406, 182, 823, 549, 520, 426, 830, 599, 430, 949, 987, 44, 729, 796,
        475, 416, 572, 748, 122, 792, 563, 83, 667, 500, 134, 993, 735, 734, 1, 755, 912, 816,
        570, 61, 810, 239, 982, 795, 306, 528, 357, 247, 19, 534, 963, 663, 70, 942, 967, 290,
        762, 621, 410, 532, 642, 697, 790, 175, 531, 425, 754, 637, 391, 272, 23, 992, 916, 644,
        492, 848, 732, 740, 452, 97, 135, 514, 166, 468, 69, 750, 467, 893, 256, 137, 958, 335,
        574, 598, 617, 437, 988, 440, 173, 981, 108, 176, 167, 66, 873, 236, 872, 843, 404, 493,
        550, 200, 606, 255, 535, 479, 56, 604, 781, 902, 620, 730, 435, 583, 947, 337, 770, 771,
        31, 101, 52, 706, 380, 92, 882, 639, 472, 603, 74, 1001, 869, 966, 107, 146, 856, 392,
        158, 994, 184, 544, 635, 924, 153, 2, 80, 577, 352, 499, 831, 232, 43, 457, 661, 62, 536,
        497, 249, 411, 805, 686, 183, 495, 87, 152, 903, 973, 53, 250, 733, 102, 204, 573, 212,
        629, 156, 328, 950, 631, 884, 49, 929, 713, 414, 904, 541, 58, 195, 782, 995, 548, 789,
        793, 46, 180, 592, 760, 370, 624, 455, 554, 652, 801, 763, 664, 596, 597, 462, 862, 804,
        119, 802, 968, 933, 557, 894, 478, 723, 210, 60, 279, 139, 170, 931, 26, 269, 361, 233,
        739, 215, 727, 786, 394, 612, 276, 881, 14, 653, 68, 433, 688, 330, 690, 703, 138, 469,
        338, 458, 399, 17, 341, 951, 990, 753, 417, 487, 657, 602, 887, 465, 65, 261, 547, 289,
        705, 187, 4, 714, 463, 454, 226, 948, 412, 263, 95, 566, 216, 120, 545, 355, 707, 298,
        136, 537, 709, 798, 253, 393, 10, 33, 450, 221, 670, 129, 530, 517, 114, 336, 213, 595,
        235, 346, 728, 388, 48, 1007, 845, 783, 27, 785, 799, 725, 312, 459, 390, 367, 806, 711,
        186, 230, 116, 1003, 871, 613, 36, 668, 281, 886, 295, 627, 564, 838, 656, 262, 832, 614,
        676, 836, 864, 13, 605, 12, 511, 926, 820, 578, 867, 446, 193, 527, 196, 773, 787, 86,
        145, 401, 999, 238, 540, 998, 228, 278, 589, 194, 658, 453, 766, 67, 30, 561, 834, 923,
        674, 507
      ]
    }
  ];

  test('performs as expected', () => {
    permsExpected.forEach(({ n, r, expected }) => {
      if (expected === 'err') {
        expect(() => subject.permutation2(n, r), `permutation(${n}, ${r}) expected to throw`).toThrow();
      } else {
        expect(subject.permutation2(n, r), `permutation(${n}, ${r}) expected ${expected}`).toStrictEqual(expected);
      }
    });
  });
});

describe('bitLength', () => {
  test('calculates the number of bits required to store the given unsigned bigint', () => {
    [
      { n: 0n, expected: 0 },
      { n: 1n, expected: 1 },
      { n: 2n, expected: 2 },
      { n: 3n, expected: 2 },
      { n: 4n, expected: 3 },
      { n: 7n, expected: 3 },
      { n: 8n, expected: 4 },
      { n: 15n, expected: 4 },
      { n: 16n, expected: 5 },
      { n: 31n, expected: 5 },
      { n: 32n, expected: 6 },
      { n: 63n, expected: 6 },
      { n: 64n, expected: 7 },
      { n: 127n, expected: 7 },
      { n: 128n, expected: 8 },
      { n: 255n, expected: 8 },
      { n: 256n, expected: 9 },
      { n: 511n, expected: 9 },
      { n: 512n, expected: 10 },
      { n: 1023n, expected: 10 },
      { n: 1024n, expected: 11 },
      { n: 2047n, expected: 11 },
      { n: 2048n, expected: 12 },
      { n: 4095n, expected: 12 },
      { n: 4096n, expected: 13 },
      { n: 8191n, expected: 13 },
      { n: 8192n, expected: 14 },
      { n: 16383n, expected: 14 },
      { n: 16384n, expected: 15 },
      { n: 32767n, expected: 15 },
      { n: 32768n, expected: 16 },
      { n: 65535n, expected: 16 },
      { n: 65536n, expected: 17 },
      { n: 131071n, expected: 17 },
      { n: 131072n, expected: 18 },
      { n: 262143n, expected: 18 },
      { n: 262144n, expected: 19 },
      { n: 141383060217536481862799697542n, expected: 97 },
      { n: 184813142392016790842646459707n, expected: 98 },
      { n: 514994434223024047778568435712n, expected: 99 },
      { n: 1159996790379937067950973929647n, expected: 100 },
    ].forEach(({ n, expected }) => {
      expect(subject.bitLength(n), `bitLength(${n}) expected ${expected}`).toBe(expected);
    });

    [
      [414856887881740073965728593681n, 99],
      [141383060217536481862799697542n, 97],
      [184813142392016790842646459707n, 98],
      [514994434223024047778568435712n, 99],
      [1159996790379937067950973929647n, 100],
      [381101659872745631035277052198n, 99],
      [1170801340026017371569760397298n, 100],
      [901386676344563059891669675397n, 100],
      [1060977509650157210085347947504n, 100],
      [675782894543969379802151692796n, 100],
      [1226311869746061357354768755160n, 100],
      [459864662556709936444962676825n, 99],
      [162429285339323834935542912023n, 98],
      [754195862158807866061032975058n, 100],
      [859140980937711533154450297855n, 100],
      [861545769879643469175880332194n, 100],
      [353127639855704906746689959867n, 99],
      [1144164724605619946730021182953n, 100],
      [768622242651426754394941299162n, 100],
      [887924384473628454576566940816n, 100],
      [222020400023661409964239738920n, 98],
      [955712853985511478719782269495n, 100],
      [1003351994378562191159311935313n, 100],
      [359188954937423310647299150878n, 99],
      [605061469138650290221098853384n, 99],
      [928962030311158486197863521364n, 100],
      [1183579948707951216715558707100n, 100],
      [902705046058715018184278560301n, 100],
      [316837591006297311168082261756n, 98],
      [621651541385240320899721549484n, 99],
      [533478057368102944199454084771n, 99],
      [309469251917201367299197323800n, 98],
    ].forEach(([r, expectedbLen]) => {
      expect(subject.bitLength(r), `bitLength(${r}) expected ${expectedbLen}`).toBe(expectedbLen);
    });
  });

  // Stress tests
  test('handles large input', () => {
    expect(subject.bitLength(subject.factorial(1<<16))).toBe(954037);
  });

  test('stress with large random bigints', () => {
    const upperBound = subject.factorial(100);
    const numTests = 100;
    for (let i = 0; i < numTests; i++) {
      const bn = subject.randomBigInt(upperBound);
      const bits = subject.bitLength(bn);
      const expectedBits = bn.toString(2).length;
      expect(bits, `bitLength(${bn}) expected ${expectedBits}`).toBe(expectedBits);
    }
  });
});

describe('bitComboToR', () => {
  test('converts as expected', () => {
    const N = 8;
    const K = 5;
    [
      248n, 244n, 242n, 241n, 236n, 234n, 233n,
      230n, 229n, 227n, 220n, 218n, 217n, 214n,
      213n, 211n, 206n, 205n, 203n, 199n, 188n,
      186n, 185n, 182n, 181n, 179n, 174n, 173n,
      171n, 167n, 158n, 157n, 155n, 151n, 143n,
      124n, 122n, 121n, 118n, 117n, 115n, 110n,
      109n, 107n, 103n,  94n,  93n,  91n,  87n,
       79n,  62n,  61n,  59n,  55n,  47n,  31n
    ].forEach((bc, i) => {
      const r = subject.bitComboToR(N, K, bc);
      const expected = BigInt(i);
      expect(r, `bitComboToR(${N}, ${K}, ${bc}n) expected ${expected}`).toBe(expected);
    });
  });
});

describe('randomBigInt', () => {
  test('will not generate random above limit', () => {
    const NUM_TESTS = 1000;
    const UPPERBOUND = 257n;
    for (let n = 0; n < NUM_TESTS; n++) {
      const bigRand = subject.randomBigInt(UPPERBOUND);
      expect(bigRand < UPPERBOUND, `randomBigInt(${UPPERBOUND}) expected ${bigRand} < ${UPPERBOUND}`).toBe(true);
    }
  });
});

// describe('randomBigInt vs randomBigInt2', () => {
//   const NUM_TESTS = 1000;
//   const UPPERBOUND = 514;
//   const _UPPERBOUND = BigInt(UPPERBOUND);

//   test(`randomBigInt ${NUM_TESTS}`, () => {
//     for (let n = 0; n < NUM_TESTS; n++) {
//       expect(subject.randomBigInt(_UPPERBOUND)).toBeLessThan(_UPPERBOUND);
//     }
//   });

//   test(`randomBigInt2 ${NUM_TESTS}`, () => {
//     for (let n = 0; n < NUM_TESTS; n++) {
//       expect(subject.randomBigInt2(_UPPERBOUND)).toBeLessThan(_UPPERBOUND);
//     }
//   });

//   // Test the spread of both functions
//   test(`Log spread over ${NUM_TESTS}`, () => {
//     const spread1 = new Array(UPPERBOUND).fill(0);
//     const spread2 = new Array(UPPERBOUND).fill(0);
//     for (let n = 0; n < NUM_TESTS; n++) {
//       const rand1 = Number(subject.randomBigInt(_UPPERBOUND));
//       spread1[rand1]++;
//       const rand2 = Number(subject.randomBigInt2(_UPPERBOUND));
//       spread2[rand2]++;
//     }
//     // Log the mean, standard deviation, and extremes
//     const mean1 = spread1.reduce((a, b) => a + b) / spread1.length;
//     const variance1 = spread1.reduce((a, b) => (a + (b - mean1) ** 2)) / spread1.length;
//     const stdDev1 = Math.sqrt(variance1);
//     const min1 = Math.min(...spread1);
//     const max1 = Math.max(...spread1);
//     console.log('randomBigInt spread:', { mean: mean1, stdDev: stdDev1, min: min1, max: max1 });

//     const mean2 = spread2.reduce((a, b) => a + b) / spread2.length;
//     const variance2 = spread2.reduce((a, b) => (a + (b - mean2) ** 2)) / spread2.length;
//     const stdDev2 = Math.sqrt(variance2);
//     const min2 = Math.min(...spread2);
//     const max2 = Math.max(...spread2);
//     console.log('randomBigInt2 spread:', { mean: mean2, stdDev: stdDev2, min: min2, max: max2 });
//   });
// });
